Fix for CVE-2015-8852
Based on upstream commit 85e8468bec9416bd7e16b0d80cb820ecd2b330c3

diff -Naur ../varnish-2.0.6.orig/bin/varnishd/cache_http.c ./bin/varnishd/cache_http.c
--- ../varnish-2.0.6.orig/bin/varnishd/cache_http.c	2009-10-13 11:05:39.000000000 +0200
+++ ./bin/varnishd/cache_http.c	2016-09-08 15:24:11.760823876 +0200
@@ -336,7 +336,7 @@
 		/* Find end of next header */
 		q = r = p;
 		while (r < t.e) {
-			if (!vct_iscrlf(*r)) {
+			if (!vct_iscrlf(r)) {
 				r++;
 				continue;
 			}
@@ -437,8 +437,8 @@
 
 	/* Third field is optional and cannot contain CTL */
 	q = p;
-	if (!vct_iscrlf(*p)) {
-		for (; !vct_iscrlf(*p); p++)
+	if (!vct_iscrlf(p)) {
+		for (; !vct_iscrlf(p); p++)
 			if (vct_isctl(*p))
 				return (-1);
 	}
diff -Naur ../varnish-2.0.6.orig/bin/varnishtest/tests/b00040.vtc ./bin/varnishtest/tests/b00040.vtc
--- ../varnish-2.0.6.orig/bin/varnishtest/tests/b00040.vtc	1970-01-01 01:00:00.000000000 +0100
+++ ./bin/varnishtest/tests/b00040.vtc	2016-09-08 15:24:23.634512271 +0200
@@ -0,0 +1,28 @@
+# $Id$
+
+test "Do not consider CR as a valid line separator"
+
+server s1 {
+	rxreq
+	txresp
+} -start
+
+varnish v1 -vcl+backend {
+        sub vcl_recv { return(pass); }
+        sub vcl_fetch {
+                if (req.http.foo) {
+                        set obj.http.Foo = req.http.foo;
+                }
+                if (req.http.bar) {
+                        set obj.http.Bar = req.http.bar;
+                }
+        }
+} -start
+
+client c1 {
+	send "GET / HTTP/1.1\r\nFoo: foo\rBar: bar\r\n\r\n"
+	rxresp
+	expect resp.http.foo == "foo\rBar: bar"
+	expect resp.http.bar == "<undef>"
+} -run
+
diff -Naur ../varnish-2.0.6.orig/bin/varnishtest/vtc_http.c ./bin/varnishtest/vtc_http.c
--- ../varnish-2.0.6.orig/bin/varnishtest/vtc_http.c	2009-12-16 11:54:18.000000000 +0100
+++ ./bin/varnishtest/vtc_http.c	2016-09-08 15:24:11.761823934 +0200
@@ -178,7 +178,7 @@
 	hdr = http_find_header(hh, hdr);
 	if (hdr != NULL)
 		return (hdr);
-	return (spec);
+	return ("<undef>");
 }
 
 static void
@@ -256,17 +256,17 @@
 	hh[n++] = p;
 	while (!vct_islws(*p))
 		p++;
-	assert(!vct_iscrlf(*p));
+	assert(!vct_iscrlf(p));
 	*p++ = '\0';
 
 	/* URL/STATUS */
 	while (vct_issp(*p))		/* XXX: H space only */
 		p++;
-	assert(!vct_iscrlf(*p));
+	assert(!vct_iscrlf(p));
 	hh[n++] = p;
 	while (!vct_islws(*p))
 		p++;
-	if (vct_iscrlf(*p)) {
+	if (vct_iscrlf(p)) {
 		hh[n++] = NULL;
 		q = p;
 		p += vct_skipcrlf(p);
@@ -277,7 +277,7 @@
 		while (vct_issp(*p))		/* XXX: H space only */
 			p++;
 		hh[n++] = p;
-		while (!vct_iscrlf(*p))
+		while (!vct_iscrlf(p))
 			p++;
 		q = p;
 		p += vct_skipcrlf(p);
@@ -287,10 +287,10 @@
 
 	while (*p != '\0') {
 		assert(n < MAX_HDR);
-		if (vct_iscrlf(*p))
+		if (vct_iscrlf(p))
 			break;
 		hh[n++] = p++;
-		while (*p != '\0' && !vct_iscrlf(*p))
+		while (*p != '\0' && !vct_iscrlf(p))
 			p++;
 		q = p;
 		p += vct_skipcrlf(p);
@@ -386,8 +386,8 @@
 			}
 			l = hp->prxbuf;
 			http_rxchar(hp, 2);
-			assert(vct_iscrlf(hp->rxbuf[l]));
-			assert(vct_iscrlf(hp->rxbuf[l + 1]));
+			assert(vct_iscrlf(&hp->rxbuf[l]));
+			assert(vct_iscrlf(&hp->rxbuf[l + 1]));
 			hp->prxbuf = l;
 			hp->rxbuf[l] = '\0';
 			if (i == 0)
diff -Naur ../varnish-2.0.6.orig/include/vct.h ./include/vct.h
--- ../varnish-2.0.6.orig/include/vct.h	2009-02-05 09:45:26.000000000 +0100
+++ ./include/vct.h	2016-09-08 15:24:11.761823934 +0200
@@ -50,12 +50,13 @@
 }
 
 #define vct_issp(x) vct_is(x, VCT_SP)
-#define vct_iscrlf(x) vct_is(x, VCT_CRLF)
 #define vct_islws(x) vct_is(x, VCT_LWS)
 #define vct_isctl(x) vct_is(x, VCT_CTL)
 #define vct_isalpha(x) vct_is(x, VCT_ALPHA)
 #define vct_issep(x) vct_is(x, VCT_SEPARATOR)
 #define vct_issepctl(x) vct_is(x, VCT_SEPARATOR | VCT_CTL)
 
+#define vct_iscrlf(p) (((p)[0] == '\r' && (p)[1] == '\n') || (p)[0] == '\n')
+
 /* NB: VCT always operate in ASCII, don't replace 0x0d with \r etc. */
 #define vct_skipcrlf(p) (p[0] == 0x0d && p[1] == 0x0a ? 2 : 1)
